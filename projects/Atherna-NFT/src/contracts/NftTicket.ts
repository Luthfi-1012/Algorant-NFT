/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"NftTicket","structs":{},"methods":[{"name":"create_ticket_event","args":[{"type":"string","name":"event_name"},{"type":"uint64","name":"event_date_timestamp"},{"type":"uint64","name":"price"},{"type":"uint64","name":"release_days"},{"type":"uint64","name":"royalty"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Create a new NFT ticket event","events":[],"recommendations":{}},{"name":"purchase_ticket","args":[{"type":"address","name":"buyer_address"},{"type":"uint64","name":"event_date"},{"type":"uint64","name":"ticket_price"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Purchase a ticket - accepts payment and confirms purchase","events":[],"recommendations":{}},{"name":"check_freeze_status","args":[{"type":"uint64","name":"event_date"},{"type":"uint64","name":"release_days"},{"type":"uint64","name":"current_time"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Check if ticket should be frozen based on event date","events":[],"recommendations":{}},{"name":"transfer_ticket","args":[{"type":"address","name":"new_owner_address"},{"type":"bool","name":"is_frozen"},{"type":"uint64","name":"transfer_fee"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Transfer ticket to another address - can optionally send transfer fee","events":[],"recommendations":{}},{"name":"get_ticket_info","args":[{"type":"string","name":"event_name"},{"type":"uint64","name":"price"},{"type":"bool","name":"is_frozen"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Get ticket information","events":[],"recommendations":{}},{"name":"update_royalty","args":[{"type":"uint64","name":"new_royalty"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update royalty rate","events":[],"recommendations":{}},{"name":"emergency_freeze","args":[],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Emergency freeze - can freeze ticket anytime","events":[],"recommendations":{}},{"name":"release_freeze","args":[{"type":"uint64","name":"event_date"},{"type":"uint64","name":"current_time"},{"type":"uint64","name":"release_days"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Release freeze if current time is past freeze release date","events":[],"recommendations":{}},{"name":"refund_ticket","args":[{"type":"address","name":"buyer_address"},{"type":"uint64","name":"refund_amount"},{"type":"uint64","name":"event_date"},{"type":"uint64","name":"current_time"},{"type":"uint64","name":"refund_deadline_days"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Refund ticket to buyer address - sends Algo back to buyer","events":[],"recommendations":{}},{"name":"cancel_event_refund","args":[{"type":"address","name":"buyer_address"},{"type":"uint64","name":"refund_amount"},{"type":"uint64","name":"event_date"},{"type":"uint64","name":"current_time"}],"returns":{"type":"string"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Emergency refund when event is cancelled - sends Algo back to buyer anytime","events":[],"recommendations":{}}],"arcs":[22,28],"networks":{},"state":{"schema":{"global":{"ints":0,"bytes":0},"local":{"ints":0,"bytes":0}},"keys":{"global":{},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[64],"errorMessage":"OnCompletion must be NoOp"},{"pc":[198],"errorMessage":"OnCompletion must be NoOp && can only call when creating"},{"pc":[206,979],"errorMessage":"invalid array length header"},{"pc":[727,1005],"errorMessage":"invalid number of bytes for arc4.bool"},{"pc":[214,987],"errorMessage":"invalid number of bytes for arc4.dynamic_array<arc4.uint8>"},{"pc":[394,719,1313,1570],"errorMessage":"invalid number of bytes for arc4.static_array<arc4.uint8, 32>"},{"pc":[225,234,243,250,401,409,561,570,579,735,997,1080,1192,1201,1210,1321,1330,1340,1352,1578,1587,1594],"errorMessage":"invalid number of bytes for arc4.uint64"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayA4IDEgMCAxMDAwMDAgODY0MDAKICAgIGJ5dGVjYmxvY2sgMHgxNTFmN2M3NSAiUmVmdW5kIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NgogICAgLy8gY2xhc3MgTmZ0VGlja2V0KEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9fX2FsZ29weV9kZWZhdWx0X2NyZWF0ZUAxNwogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQKICAgIHB1c2hieXRlc3MgMHhlNzExNTQ4ZSAweGQ3YTljZWJlIDB4NzJmYWQ4MzggMHhmOTBiMzVmMSAweDNiNGI5NzlmIDB4NGRjMzUyN2EgMHg4NGEzYmE2NCAweDQyMzg3YTNhIDB4MDQ5MThjYjIgMHg2YmFhMmRmZiAvLyBtZXRob2QgImNyZWF0ZV90aWNrZXRfZXZlbnQoc3RyaW5nLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NClzdHJpbmciLCBtZXRob2QgInB1cmNoYXNlX3RpY2tldChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpc3RyaW5nIiwgbWV0aG9kICJjaGVja19mcmVlemVfc3RhdHVzKHVpbnQ2NCx1aW50NjQsdWludDY0KXN0cmluZyIsIG1ldGhvZCAidHJhbnNmZXJfdGlja2V0KGFkZHJlc3MsYm9vbCx1aW50NjQpc3RyaW5nIiwgbWV0aG9kICJnZXRfdGlja2V0X2luZm8oc3RyaW5nLHVpbnQ2NCxib29sKXN0cmluZyIsIG1ldGhvZCAidXBkYXRlX3JveWFsdHkodWludDY0KXN0cmluZyIsIG1ldGhvZCAiZW1lcmdlbmN5X2ZyZWV6ZSgpc3RyaW5nIiwgbWV0aG9kICJyZWxlYXNlX2ZyZWV6ZSh1aW50NjQsdWludDY0LHVpbnQ2NClzdHJpbmciLCBtZXRob2QgInJlZnVuZF90aWNrZXQoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpc3RyaW5nIiwgbWV0aG9kICJjYW5jZWxfZXZlbnRfcmVmdW5kKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpc3RyaW5nIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlX3RpY2tldF9ldmVudCBwdXJjaGFzZV90aWNrZXQgY2hlY2tfZnJlZXplX3N0YXR1cyB0cmFuc2Zlcl90aWNrZXQgZ2V0X3RpY2tldF9pbmZvIHVwZGF0ZV9yb3lhbHR5IG1haW5fZW1lcmdlbmN5X2ZyZWV6ZV9yb3V0ZUAxMCByZWxlYXNlX2ZyZWV6ZSByZWZ1bmRfdGlja2V0IGNhbmNlbF9ldmVudF9yZWZ1bmQKICAgIGVycgoKbWFpbl9lbWVyZ2VuY3lfZnJlZXplX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTE5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1MDAyMjU0Njk2MzZiNjU3NDIwNjY3MjZmN2E2NTZlMjA3NjY5NjEyMDY1NmQ2NTcyNjc2NTZlNjM3OTIwNjY3MjY1NjU3YTY1CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fX19hbGdvcHlfZGVmYXVsdF9jcmVhdGVAMTc6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgJiYKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC5jcmVhdGVfdGlja2V0X2V2ZW50W3JvdXRpbmddKCkgLT4gdm9pZDoKY3JlYXRlX3RpY2tldF9ldmVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjcKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzIgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuZHluYW1pY19hcnJheTxhcmM0LnVpbnQ4PgogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGxlbgogICAgaW50Y18wIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBsZW4KICAgIGludGNfMCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTctMTgKICAgIC8vICMgU2ltcGxlIHZhbGlkYXRpb24KICAgIC8vIGlmIGV2ZW50X2RhdGVfdGltZXN0YW1wID09IFVJbnQ2NCgwKToKICAgIGJueiBjcmVhdGVfdGlja2V0X2V2ZW50X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTkKICAgIC8vIHJldHVybiBTdHJpbmcoIkludmFsaWQgZXZlbnQgZGF0ZSIpCiAgICBwdXNoYnl0ZXMgIkludmFsaWQgZXZlbnQgZGF0ZSIKCmNyZWF0ZV90aWNrZXRfZXZlbnRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQuY3JlYXRlX3RpY2tldF9ldmVudEA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKY3JlYXRlX3RpY2tldF9ldmVudF9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToyMQogICAgLy8gaWYgcHJpY2UgPT0gVUludDY0KDApOgogICAgZHVwCiAgICBibnogY3JlYXRlX3RpY2tldF9ldmVudF9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjIyCiAgICAvLyByZXR1cm4gU3RyaW5nKCJQcmljZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIikKICAgIHB1c2hieXRlcyAiUHJpY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjcKICAgIC8vIEBhYmltZXRob2QoKQogICAgYiBjcmVhdGVfdGlja2V0X2V2ZW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LmNyZWF0ZV90aWNrZXRfZXZlbnRANgoKY3JlYXRlX3RpY2tldF9ldmVudF9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToyNC0yNQogICAgLy8gIyBSZXR1cm4gc3VjY2VzcyBtZXNzYWdlIHdpdGggZXZlbnQgZGV0YWlscwogICAgLy8gcmVzdWx0ID0gU3RyaW5nKCJUaWNrZXQgZXZlbnQgY3JlYXRlZDogIikKICAgIHB1c2hieXRlcyAiVGlja2V0IGV2ZW50IGNyZWF0ZWQ6ICIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjI2CiAgICAvLyByZXN1bHQgPSByZXN1bHQgKyBldmVudF9uYW1lICsgU3RyaW5nKCIgLSBFdmVudCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSIpCiAgICBkaWcgMgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgIiAtIEV2ZW50IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo3CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGIgY3JlYXRlX3RpY2tldF9ldmVudF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC5jcmVhdGVfdGlja2V0X2V2ZW50QDYKCgovLyBzbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQucHVyY2hhc2VfdGlja2V0W3JvdXRpbmddKCkgLT4gdm9pZDoKcHVyY2hhc2VfdGlja2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MjkKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGxlbgogICAgaW50Y18wIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTozNS0zNgogICAgLy8gIyBWYWxpZGF0ZSB0aWNrZXQgcHJpY2UKICAgIC8vIGlmIHRpY2tldF9wcmljZSA9PSBVSW50NjQoMCk6CiAgICBibnogcHVyY2hhc2VfdGlja2V0X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MzcKICAgIC8vIHJldHVybiBTdHJpbmcoIlRpY2tldCBwcmljZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIikKICAgIHB1c2hieXRlcyAiVGlja2V0IHByaWNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAiCgpwdXJjaGFzZV90aWNrZXRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQucHVyY2hhc2VfdGlja2V0QDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToyOQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKcHVyY2hhc2VfdGlja2V0X2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjQ4LTQ5CiAgICAvLyAjIFB1cmNoYXNlIHN1Y2Nlc3NmdWwgLSBwYXltZW50IHJlY2VpdmVkIGJ5IGNvbnRyYWN0CiAgICAvLyByZXN1bHQgPSBTdHJpbmcoIlRpY2tldCBwdXJjaGFzZWQgc3VjY2Vzc2Z1bGx5LiBUcmFuc2ZlciBmcm96ZW4gdG8gcHJldmVudCBzY2FscGluZyB1bnRpbCBldmVudCBkYXRlLiIpCiAgICBwdXNoYnl0ZXMgIlRpY2tldCBwdXJjaGFzZWQgc3VjY2Vzc2Z1bGx5LiBUcmFuc2ZlciBmcm96ZW4gdG8gcHJldmVudCBzY2FscGluZyB1bnRpbCBldmVudCBkYXRlLiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjI5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGIgcHVyY2hhc2VfdGlja2V0X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LnB1cmNoYXNlX3RpY2tldEA0CgoKLy8gc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LmNoZWNrX2ZyZWV6ZV9zdGF0dXNbcm91dGluZ10oKSAtPiB2b2lkOgpjaGVja19mcmVlemVfc3RhdHVzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NTIKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NTUKICAgIC8vIGRheXNfaW5fc2Vjb25kcyA9IHJlbGVhc2VfZGF5cyAqIFVJbnQ2NCg4NjQwMCkKICAgIHN3YXAKICAgIGludGMgNCAvLyA4NjQwMAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NTYKICAgIC8vIHJlbGVhc2VfdGltZXN0YW1wID0gZXZlbnRfZGF0ZSAtIGRheXNfaW5fc2Vjb25kcwogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo1OAogICAgLy8gaWYgY3VycmVudF90aW1lID49IHJlbGVhc2VfdGltZXN0YW1wOgogICAgPj0KICAgIGJ6IGNoZWNrX2ZyZWV6ZV9zdGF0dXNfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjU5CiAgICAvLyByZXR1cm4gU3RyaW5nKCJGcmVlemUgY2FuIGJlIHJlbGVhc2VkIC0gdGlja2V0IGNhbiBub3cgYmUgdHJhbnNmZXJyZWQiKQogICAgcHVzaGJ5dGVzICJGcmVlemUgY2FuIGJlIHJlbGVhc2VkIC0gdGlja2V0IGNhbiBub3cgYmUgdHJhbnNmZXJyZWQiCgpjaGVja19mcmVlemVfc3RhdHVzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LmNoZWNrX2ZyZWV6ZV9zdGF0dXNANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjUyCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpjaGVja19mcmVlemVfc3RhdHVzX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NjMKICAgIC8vIHJlc3VsdCA9IFN0cmluZygiVGlja2V0IHN0aWxsIGZyb3plbi4gV2lsbCBiZSByZWxlYXNlZCBzb29uLiIpCiAgICBwdXNoYnl0ZXMgIlRpY2tldCBzdGlsbCBmcm96ZW4uIFdpbGwgYmUgcmVsZWFzZWQgc29vbi4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo1MgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBiIGNoZWNrX2ZyZWV6ZV9zdGF0dXNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQuY2hlY2tfZnJlZXplX3N0YXR1c0A0CgoKLy8gc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LnRyYW5zZmVyX3RpY2tldFtyb3V0aW5nXSgpIC0+IHZvaWQ6CnRyYW5zZmVyX3RpY2tldDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjY2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5ib29sCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo3NAogICAgLy8gaWYgaXNfZnJvemVuLm5hdGl2ZToKICAgIGludGNfMiAvLyAwCiAgICBnZXRiaXQKICAgIGJ6IHRyYW5zZmVyX3RpY2tldF9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyByZXR1cm4gU3RyaW5nKCJDYW5ub3QgdHJhbnNmZXIgLSB0aWNrZXQgaXMgZnJvemVuLiBXYWl0IHVudGlsIGZyZWV6ZSByZWxlYXNlIGRhdGUuIikKICAgIHB1c2hieXRlcyAiQ2Fubm90IHRyYW5zZmVyIC0gdGlja2V0IGlzIGZyb3plbi4gV2FpdCB1bnRpbCBmcmVlemUgcmVsZWFzZSBkYXRlLiIKCnRyYW5zZmVyX3RpY2tldF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC50cmFuc2Zlcl90aWNrZXRAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo2NgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKdHJhbnNmZXJfdGlja2V0X2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5Ojc3LTc4CiAgICAvLyAjIElmIHRyYW5zZmVyIGZlZSBpcyBzcGVjaWZpZWQgKD4gMCksIHNlbmQgaXQgdG8gbmV3IG93bmVyCiAgICAvLyBpZiB0cmFuc2Zlcl9mZWUgPiBVSW50NjQoMCk6CiAgICBkdXAKICAgIGJ6IHRyYW5zZmVyX3RpY2tldF9lbHNlX2JvZHlAOAogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6ODUKICAgIC8vIGlmIHBheW1lbnRfYW1vdW50IDwgbWluX2JhbGFuY2U6CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5Ojc5LTgxCiAgICAvLyAjIE1pbmltdW0gYmFsYW5jZSByZXF1aXJlbWVudDogMC4xIEFsZ28gKDEwMCwwMDAgbWljcm9BbGdvcykKICAgIC8vICMgQWNjb3VudCBtdXN0IGJlIGFjdGl2ZSAoaGF2ZSBtaW5pbXVtIGJhbGFuY2UpIGJlZm9yZSByZWNlaXZpbmcgcGF5bWVudAogICAgLy8gbWluX2JhbGFuY2UgPSBVSW50NjQoMTAwXzAwMCkgICMgMC4xIEFsZ28gbWluaW11bQogICAgaW50Y18zIC8vIDEwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6ODUKICAgIC8vIGlmIHBheW1lbnRfYW1vdW50IDwgbWluX2JhbGFuY2U6CiAgICA8CiAgICBibnogdHJhbnNmZXJfdGlja2V0X2lmX2JvZHlANQogICAgZHVwCgp0cmFuc2Zlcl90aWNrZXRfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6ODgtOTUKICAgIC8vICMgU2VuZCB0cmFuc2ZlciBmZWUgdG8gbmV3IG93bmVyIHVzaW5nIGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyAjIE5vdGU6IFJlY2VpdmVyIGFjY291bnQgbXVzdCBiZSBhY3RpdmUgKGhhdmUgcmVjZWl2ZWQgYXQgbGVhc3QgMC4xIEFsZ28gYmVmb3JlKQogICAgLy8gIyBPciBzZW5kIG1pbmltdW0gMC4xIEFsZ28gdG8gYWN0aXZhdGUgaXQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1uZXdfb3duZXJfYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYW1vdW50PXBheW1lbnRfYW1vdW50LAogICAgLy8gICAgIGZlZT1VSW50NjQoMCksICAjIEZlZSBwb29saW5nIC0gY2FsbGVyIHBheXMKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6ODgtOTEKICAgIC8vICMgU2VuZCB0cmFuc2ZlciBmZWUgdG8gbmV3IG93bmVyIHVzaW5nIGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyAjIE5vdGU6IFJlY2VpdmVyIGFjY291bnQgbXVzdCBiZSBhY3RpdmUgKGhhdmUgcmVjZWl2ZWQgYXQgbGVhc3QgMC4xIEFsZ28gYmVmb3JlKQogICAgLy8gIyBPciBzZW5kIG1pbmltdW0gMC4xIEFsZ28gdG8gYWN0aXZhdGUgaXQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5Ojk0CiAgICAvLyBmZWU9VUludDY0KDApLCAgIyBGZWUgcG9vbGluZyAtIGNhbGxlciBwYXlzCiAgICBpbnRjXzIgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5Ojg4LTk1CiAgICAvLyAjIFNlbmQgdHJhbnNmZXIgZmVlIHRvIG5ldyBvd25lciB1c2luZyBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gIyBOb3RlOiBSZWNlaXZlciBhY2NvdW50IG11c3QgYmUgYWN0aXZlIChoYXZlIHJlY2VpdmVkIGF0IGxlYXN0IDAuMSBBbGdvIGJlZm9yZSkKICAgIC8vICMgT3Igc2VuZCBtaW5pbXVtIDAuMSBBbGdvIHRvIGFjdGl2YXRlIGl0CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9bmV3X293bmVyX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGFtb3VudD1wYXltZW50X2Ftb3VudCwKICAgIC8vICAgICBmZWU9VUludDY0KDApLCAgIyBGZWUgcG9vbGluZyAtIGNhbGxlciBwYXlzCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6OTcKICAgIC8vIHJlc3VsdCA9IFN0cmluZygiVGlja2V0IHRyYW5zZmVycmVkIHN1Y2Nlc3NmdWxseS4gVHJhbnNmZXIgZmVlIHNlbnQgdG8gbmV3IG93bmVyLiIpCiAgICBwdXNoYnl0ZXMgIlRpY2tldCB0cmFuc2ZlcnJlZCBzdWNjZXNzZnVsbHkuIFRyYW5zZmVyIGZlZSBzZW50IHRvIG5ldyBvd25lci4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo2NgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBiIHRyYW5zZmVyX3RpY2tldF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC50cmFuc2Zlcl90aWNrZXRAMTAKCnRyYW5zZmVyX3RpY2tldF9pZl9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weTo3OS04MQogICAgLy8gIyBNaW5pbXVtIGJhbGFuY2UgcmVxdWlyZW1lbnQ6IDAuMSBBbGdvICgxMDAsMDAwIG1pY3JvQWxnb3MpCiAgICAvLyAjIEFjY291bnQgbXVzdCBiZSBhY3RpdmUgKGhhdmUgbWluaW11bSBiYWxhbmNlKSBiZWZvcmUgcmVjZWl2aW5nIHBheW1lbnQKICAgIC8vIG1pbl9iYWxhbmNlID0gVUludDY0KDEwMF8wMDApICAjIDAuMSBBbGdvIG1pbmltdW0KICAgIGludGNfMyAvLyAxMDAwMDAKICAgIGIgdHJhbnNmZXJfdGlja2V0X2FmdGVyX2lmX2Vsc2VANgoKdHJhbnNmZXJfdGlja2V0X2Vsc2VfYm9keUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6OTkKICAgIC8vIHJlc3VsdCA9IFN0cmluZygiVGlja2V0IHRyYW5zZmVycmVkIHN1Y2Nlc3NmdWxseSB0byBuZXcgb3duZXIuIikKICAgIHB1c2hieXRlcyAiVGlja2V0IHRyYW5zZmVycmVkIHN1Y2Nlc3NmdWxseSB0byBuZXcgb3duZXIuIgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6NjYKICAgIC8vIEBhYmltZXRob2QoKQogICAgYiB0cmFuc2Zlcl90aWNrZXRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQudHJhbnNmZXJfdGlja2V0QDEwCgoKLy8gc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LmdldF90aWNrZXRfaW5mb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldF90aWNrZXRfaW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMiAvLyAwCiAgICBleHRyYWN0X3VpbnQxNiAvLyBvbiBlcnJvcjogaW52YWxpZCBhcnJheSBsZW5ndGggaGVhZGVyCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5keW5hbWljX2FycmF5PGFyYzQudWludDg+CiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5ib29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMDYKICAgIC8vIHN0YXR1cyA9IFN0cmluZygiRnJvemVuIikgaWYgaXNfZnJvemVuLm5hdGl2ZSBlbHNlIFN0cmluZygiVW5mcm96ZW4iKQogICAgaW50Y18yIC8vIDAKICAgIGdldGJpdAogICAgYnogZ2V0X3RpY2tldF9pbmZvX3Rlcm5hcnlfZmFsc2VAMwogICAgcHVzaGJ5dGVzICJGcm96ZW4iCgpnZXRfdGlja2V0X2luZm9fdGVybmFyeV9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTA3CiAgICAvLyByZXN1bHQgPSBTdHJpbmcoIkV2ZW50OiAiKSArIGV2ZW50X25hbWUKICAgIHB1c2hieXRlcyAiRXZlbnQ6ICIKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjEwOAogICAgLy8gcmVzdWx0ID0gcmVzdWx0ICsgU3RyaW5nKCIsIFN0YXR1czogIikgKyBzdGF0dXMKICAgIHB1c2hieXRlcyAiLCBTdGF0dXM6ICIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMDMKICAgIC8vIEBhYmltZXRob2QoKQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmdldF90aWNrZXRfaW5mb190ZXJuYXJ5X2ZhbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMDYKICAgIC8vIHN0YXR1cyA9IFN0cmluZygiRnJvemVuIikgaWYgaXNfZnJvemVuLm5hdGl2ZSBlbHNlIFN0cmluZygiVW5mcm96ZW4iKQogICAgcHVzaGJ5dGVzICJVbmZyb3plbiIKICAgIGIgZ2V0X3RpY2tldF9pbmZvX3Rlcm5hcnlfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC51cGRhdGVfcm95YWx0eVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZV9yb3lhbHR5OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTExCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjExNAogICAgLy8gaWYgbmV3X3JveWFsdHkgPiBVSW50NjQoMTAwMDApOgogICAgcHVzaGludCAxMDAwMCAvLyAxMDAwMAogICAgPgogICAgYnogdXBkYXRlX3JveWFsdHlfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMTUKICAgIC8vIHJldHVybiBTdHJpbmcoIlJveWFsdHkgY2Fubm90IGV4Y2VlZCAxMDAlICgxMDAwMCBiYXNpcyBwb2ludHMpIikKICAgIHB1c2hieXRlcyAiUm95YWx0eSBjYW5ub3QgZXhjZWVkIDEwMCUgKDEwMDAwIGJhc2lzIHBvaW50cykiCgp1cGRhdGVfcm95YWx0eV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC51cGRhdGVfcm95YWx0eUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTExCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgp1cGRhdGVfcm95YWx0eV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMTcKICAgIC8vIHJldHVybiBTdHJpbmcoIlJveWFsdHkgdXBkYXRlZCBzdWNjZXNzZnVsbHkiKQogICAgcHVzaGJ5dGVzICJSb3lhbHR5IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTExCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGIgdXBkYXRlX3JveWFsdHlfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQudXBkYXRlX3JveWFsdHlANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC5yZWxlYXNlX2ZyZWV6ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlbGVhc2VfZnJlZXplOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTI0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjEyNwogICAgLy8gZGF5c19pbl9zZWNvbmRzID0gcmVsZWFzZV9kYXlzICogVUludDY0KDg2NDAwKQogICAgaW50YyA0IC8vIDg2NDAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMjgKICAgIC8vIHJlbGVhc2VfdGltZXN0YW1wID0gZXZlbnRfZGF0ZSAtIGRheXNfaW5fc2Vjb25kcwogICAgdW5jb3ZlciAyCiAgICBzd2FwCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMzAKICAgIC8vIGlmIGN1cnJlbnRfdGltZSA8IHJlbGVhc2VfdGltZXN0YW1wOgogICAgPAogICAgYnogcmVsZWFzZV9mcmVlemVfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMzEKICAgIC8vIHJldHVybiBTdHJpbmcoIkNhbm5vdCByZWxlYXNlIGZyZWV6ZSB5ZXQgLSB0b28gZWFybHkiKQogICAgcHVzaGJ5dGVzICJDYW5ub3QgcmVsZWFzZSBmcmVlemUgeWV0IC0gdG9vIGVhcmx5IgoKcmVsZWFzZV9mcmVlemVfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQucmVsZWFzZV9mcmVlemVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjEyNAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKcmVsZWFzZV9mcmVlemVfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTMzCiAgICAvLyByZXR1cm4gU3RyaW5nKCJGcmVlemUgbWFudWFsbHkgcmVsZWFzZWQiKQogICAgcHVzaGJ5dGVzICJGcmVlemUgbWFudWFsbHkgcmVsZWFzZWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMjQKICAgIC8vIEBhYmltZXRob2QoKQogICAgYiByZWxlYXNlX2ZyZWV6ZV9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC5yZWxlYXNlX2ZyZWV6ZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LnJlZnVuZF90aWNrZXRbcm91dGluZ10oKSAtPiB2b2lkOgpyZWZ1bmRfdGlja2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTM1CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxNDUtMTQ2CiAgICAvLyAjIFZhbGlkYXRpb246IEV2ZW50IG11c3Qgbm90IGhhdmUgb2NjdXJyZWQgeWV0CiAgICAvLyBpZiBjdXJyZW50X3RpbWUgPj0gZXZlbnRfZGF0ZToKICAgIDw9CiAgICBieiByZWZ1bmRfdGlja2V0X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTQ3CiAgICAvLyByZXR1cm4gU3RyaW5nKCJDYW5ub3QgcmVmdW5kIC0gZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQiKQogICAgcHVzaGJ5dGVzICJDYW5ub3QgcmVmdW5kIC0gZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQiCgpyZWZ1bmRfdGlja2V0X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LnJlZnVuZF90aWNrZXRAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMzUKICAgIC8vIEBhYmltZXRob2QoKQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnJlZnVuZF90aWNrZXRfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTQ5LTE1MAogICAgLy8gIyBWYWxpZGF0aW9uOiBSZWZ1bmQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAKICAgIC8vIGlmIHJlZnVuZF9hbW91bnQgPT0gVUludDY0KDApOgogICAgZGlnIDMKICAgIGJueiByZWZ1bmRfdGlja2V0X2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTUxCiAgICAvLyByZXR1cm4gU3RyaW5nKCJSZWZ1bmQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAiKQogICAgYnl0ZWNfMSAvLyAiUmVmdW5kIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTM1CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGIgcmVmdW5kX3RpY2tldF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC5yZWZ1bmRfdGlja2V0QDExCgpyZWZ1bmRfdGlja2V0X2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE1My0xNTUKICAgIC8vICMgQ2FsY3VsYXRlIHJlZnVuZCBkZWFkbGluZSB0aW1lc3RhbXAKICAgIC8vICMgUmVmdW5kIGRlYWRsaW5lIGlzIFggZGF5cyBiZWZvcmUgZXZlbnQgKHRvIHByZXZlbnQgbGFzdC1taW51dGUgcmVmdW5kcykKICAgIC8vIGRheXNfaW5fc2Vjb25kcyA9IHJlZnVuZF9kZWFkbGluZV9kYXlzICogVUludDY0KDg2NDAwKQogICAgZHVwCiAgICBpbnRjIDQgLy8gODY0MDAKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE1NgogICAgLy8gcmVmdW5kX2RlYWRsaW5lID0gZXZlbnRfZGF0ZSAtIGRheXNfaW5fc2Vjb25kcwogICAgZGlnIDMKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE1OC0xNTkKICAgIC8vICMgVmFsaWRhdGlvbjogUmVmdW5kIG11c3QgYmUgcmVxdWVzdGVkIGJlZm9yZSBkZWFkbGluZQogICAgLy8gaWYgY3VycmVudF90aW1lID49IHJlZnVuZF9kZWFkbGluZToKICAgIGRpZyAyCiAgICA8PQogICAgYnogcmVmdW5kX3RpY2tldF9hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE2MAogICAgLy8gcmV0dXJuIFN0cmluZygiQ2Fubm90IHJlZnVuZCAtIHJlZnVuZCBkZWFkbGluZSBoYXMgcGFzc2VkIikKICAgIHB1c2hieXRlcyAiQ2Fubm90IHJlZnVuZCAtIHJlZnVuZCBkZWFkbGluZSBoYXMgcGFzc2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTM1CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGIgcmVmdW5kX3RpY2tldF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy5uZnRfdGlja2V0LmNvbnRyYWN0Lk5mdFRpY2tldC5yZWZ1bmRfdGlja2V0QDExCgpyZWZ1bmRfdGlja2V0X2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE3MAogICAgLy8gaWYgcGF5bWVudF9hbW91bnQgPCBtaW5fYmFsYW5jZToKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxNjItMTY2CiAgICAvLyAjIFNlbmQgcmVmdW5kIHBheW1lbnQgdG8gYnV5ZXIgdXNpbmcgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vICMgTm90ZTogQ29udHJhY3QgbXVzdCBoYXZlIHN1ZmZpY2llbnQgYmFsYW5jZSwgY2hlY2tlZCBieSBibG9ja2NoYWluCiAgICAvLyAjIE5vdGU6IFJlY2VpdmVyIGFjY291bnQgbXVzdCBiZSBhY3RpdmUgKG1pbmltdW0gMC4xIEFsZ28gYmFsYW5jZSByZXF1aXJlbWVudCkKICAgIC8vICMgTWluaW11bSBiYWxhbmNlOiAwLjEgQWxnbyAoMTAwLDAwMCBtaWNyb0FsZ29zKQogICAgLy8gbWluX2JhbGFuY2UgPSBVSW50NjQoMTAwXzAwMCkKICAgIGludGNfMyAvLyAxMDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE3MAogICAgLy8gaWYgcGF5bWVudF9hbW91bnQgPCBtaW5fYmFsYW5jZToKICAgIDwKICAgIGJueiByZWZ1bmRfdGlja2V0X2lmX2JvZHlAOAogICAgZGlnIDMKCnJlZnVuZF90aWNrZXRfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTczLTE3NwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWJ1eWVyX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGFtb3VudD1wYXltZW50X2Ftb3VudCwKICAgIC8vICAgICBmZWU9VUludDY0KDApLCAgIyBGZWUgcG9vbGluZyAtIGNhbGxlciBwYXlzIGZlZQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyA0CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxNzMKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE3NgogICAgLy8gZmVlPVVJbnQ2NCgwKSwgICMgRmVlIHBvb2xpbmcgLSBjYWxsZXIgcGF5cyBmZWUKICAgIGludGNfMiAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTczLTE3NwogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPWJ1eWVyX2FkZHJlc3MubmF0aXZlLAogICAgLy8gICAgIGFtb3VudD1wYXltZW50X2Ftb3VudCwKICAgIC8vICAgICBmZWU9VUludDY0KDApLCAgIyBGZWUgcG9vbGluZyAtIGNhbGxlciBwYXlzIGZlZQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE3OQogICAgLy8gcmVzdWx0ID0gU3RyaW5nKCJSZWZ1bmQgc2VudCBzdWNjZXNzZnVsbHkgdG8gYnV5ZXIgYWRkcmVzcy4iKQogICAgcHVzaGJ5dGVzICJSZWZ1bmQgc2VudCBzdWNjZXNzZnVsbHkgdG8gYnV5ZXIgYWRkcmVzcy4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxMzUKICAgIC8vIEBhYmltZXRob2QoKQogICAgYiByZWZ1bmRfdGlja2V0X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LnJlZnVuZF90aWNrZXRAMTEKCnJlZnVuZF90aWNrZXRfaWZfYm9keUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTYyLTE2NgogICAgLy8gIyBTZW5kIHJlZnVuZCBwYXltZW50IHRvIGJ1eWVyIHVzaW5nIGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyAjIE5vdGU6IENvbnRyYWN0IG11c3QgaGF2ZSBzdWZmaWNpZW50IGJhbGFuY2UsIGNoZWNrZWQgYnkgYmxvY2tjaGFpbgogICAgLy8gIyBOb3RlOiBSZWNlaXZlciBhY2NvdW50IG11c3QgYmUgYWN0aXZlIChtaW5pbXVtIDAuMSBBbGdvIGJhbGFuY2UgcmVxdWlyZW1lbnQpCiAgICAvLyAjIE1pbmltdW0gYmFsYW5jZTogMC4xIEFsZ28gKDEwMCwwMDAgbWljcm9BbGdvcykKICAgIC8vIG1pbl9iYWxhbmNlID0gVUludDY0KDEwMF8wMDApCiAgICBpbnRjXzMgLy8gMTAwMDAwCiAgICBiIHJlZnVuZF90aWNrZXRfYWZ0ZXJfaWZfZWxzZUA5CgoKLy8gc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LmNhbmNlbF9ldmVudF9yZWZ1bmRbcm91dGluZ10oKSAtPiB2b2lkOgpjYW5jZWxfZXZlbnRfcmVmdW5kOgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTgyCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgbGVuCiAgICBpbnRjXzAgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGxlbgogICAgaW50Y18wIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxOTEtMTkyCiAgICAvLyAjIFZhbGlkYXRpb246IFJlZnVuZCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAogICAgLy8gaWYgcmVmdW5kX2Ftb3VudCA9PSBVSW50NjQoMCk6CiAgICBibnogY2FuY2VsX2V2ZW50X3JlZnVuZF9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjE5MwogICAgLy8gcmV0dXJuIFN0cmluZygiUmVmdW5kIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIikKICAgIGJ5dGVjXzEgLy8gIlJlZnVuZCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCIKCmNhbmNlbF9ldmVudF9yZWZ1bmRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMubmZ0X3RpY2tldC5jb250cmFjdC5OZnRUaWNrZXQuY2FuY2VsX2V2ZW50X3JlZnVuZEA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTgyCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpjYW5jZWxfZXZlbnRfcmVmdW5kX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjIwNAogICAgLy8gaWYgcGF5bWVudF9hbW91bnQgPCBtaW5fYmFsYW5jZToKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MTk1LTIwMAogICAgLy8gIyBTZW5kIHJlZnVuZCBwYXltZW50IHRvIGJ1eWVyIHVzaW5nIGlubmVyIHRyYW5zYWN0aW9uCiAgICAvLyAjIEVtZXJnZW5jeSByZWZ1bmQgY2FuIGJlIHByb2Nlc3NlZCBhbnl0aW1lIChldmVudCBjYW5jZWxsZWQgc2NlbmFyaW8pCiAgICAvLyAjIE5vdGU6IENvbnRyYWN0IG11c3QgaGF2ZSBzdWZmaWNpZW50IGJhbGFuY2UsIGNoZWNrZWQgYnkgYmxvY2tjaGFpbgogICAgLy8gIyBOb3RlOiBSZWNlaXZlciBhY2NvdW50IG11c3QgYmUgYWN0aXZlIChtaW5pbXVtIDAuMSBBbGdvIGJhbGFuY2UgcmVxdWlyZW1lbnQpCiAgICAvLyAjIE1pbmltdW0gYmFsYW5jZTogMC4xIEFsZ28gKDEwMCwwMDAgbWljcm9BbGdvcykKICAgIC8vIG1pbl9iYWxhbmNlID0gVUludDY0KDEwMF8wMDApCiAgICBpbnRjXzMgLy8gMTAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToyMDQKICAgIC8vIGlmIHBheW1lbnRfYW1vdW50IDwgbWluX2JhbGFuY2U6CiAgICA8CiAgICBibnogY2FuY2VsX2V2ZW50X3JlZnVuZF9pZl9ib2R5QDQKICAgIGR1cAoKY2FuY2VsX2V2ZW50X3JlZnVuZF9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToyMDctMjExCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YnV5ZXJfYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYW1vdW50PXBheW1lbnRfYW1vdW50LAogICAgLy8gICAgIGZlZT1VSW50NjQoMCksICAjIEZlZSBwb29saW5nIC0gY2FsbGVyIHBheXMgZmVlCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9uZnRfdGlja2V0L2NvbnRyYWN0LnB5OjIwNwogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MjEwCiAgICAvLyBmZWU9VUludDY0KDApLCAgIyBGZWUgcG9vbGluZyAtIGNhbGxlciBwYXlzIGZlZQogICAgaW50Y18yIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToyMDctMjExCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9YnV5ZXJfYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgYW1vdW50PXBheW1lbnRfYW1vdW50LAogICAgLy8gICAgIGZlZT1VSW50NjQoMCksICAjIEZlZSBwb29saW5nIC0gY2FsbGVyIHBheXMgZmVlCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL25mdF90aWNrZXQvY29udHJhY3QucHk6MjEzCiAgICAvLyByZXN1bHQgPSBTdHJpbmcoIkV2ZW50IGNhbmNlbGxhdGlvbiByZWZ1bmQgc2VudCBzdWNjZXNzZnVsbHkgdG8gYnV5ZXIuIikKICAgIHB1c2hieXRlcyAiRXZlbnQgY2FuY2VsbGF0aW9uIHJlZnVuZCBzZW50IHN1Y2Nlc3NmdWxseSB0byBidXllci4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxODIKICAgIC8vIEBhYmltZXRob2QoKQogICAgYiBjYW5jZWxfZXZlbnRfcmVmdW5kX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzLm5mdF90aWNrZXQuY29udHJhY3QuTmZ0VGlja2V0LmNhbmNlbF9ldmVudF9yZWZ1bmRANwoKY2FuY2VsX2V2ZW50X3JlZnVuZF9pZl9ib2R5QDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbmZ0X3RpY2tldC9jb250cmFjdC5weToxOTUtMjAwCiAgICAvLyAjIFNlbmQgcmVmdW5kIHBheW1lbnQgdG8gYnV5ZXIgdXNpbmcgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vICMgRW1lcmdlbmN5IHJlZnVuZCBjYW4gYmUgcHJvY2Vzc2VkIGFueXRpbWUgKGV2ZW50IGNhbmNlbGxlZCBzY2VuYXJpbykKICAgIC8vICMgTm90ZTogQ29udHJhY3QgbXVzdCBoYXZlIHN1ZmZpY2llbnQgYmFsYW5jZSwgY2hlY2tlZCBieSBibG9ja2NoYWluCiAgICAvLyAjIE5vdGU6IFJlY2VpdmVyIGFjY291bnQgbXVzdCBiZSBhY3RpdmUgKG1pbmltdW0gMC4xIEFsZ28gYmFsYW5jZSByZXF1aXJlbWVudCkKICAgIC8vICMgTWluaW11bSBiYWxhbmNlOiAwLjEgQWxnbyAoMTAwLDAwMCBtaWNyb0FsZ29zKQogICAgLy8gbWluX2JhbGFuY2UgPSBVSW50NjQoMTAwXzAwMCkKICAgIGludGNfMyAvLyAxMDAwMDAKICAgIGIgY2FuY2VsX2V2ZW50X3JlZnVuZF9hZnRlcl9pZl9lbHNlQDUK","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"},"byteCode":{"approval":"CyAFCAEAoI0GgKMFJgIEFR98dSRSZWZ1bmQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAxG0EAgjEZFEQxGESCCgTnEVSOBNepzr4EcvrYOAT5CzXxBDtLl58ETcNSegSEo7pkBEI4ejoEBJGMsgRrqi3/NhoAjgoAOADyAZkCNgM9A6AAAQQQBIgFiQCAKBUffHUAIlRpY2tldCBmcm96ZW4gdmlhIGVtZXJnZW5jeSBmcmVlemWwI0MxGRQxGBQQRCNDNhoBSSRZgQIISwEVEkRXAgA2GgJJFSISRBc2GgNJFSISRBdMNhoEFSISRDYaBRUiEkRAACKAEkludmFsaWQgZXZlbnQgZGF0ZUkVFlcGAkxQKExQsCNDSUAAIYAcUHJpY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gMEL/zYAWVGlja2V0IGV2ZW50IGNyZWF0ZWQ6IEsCUIAdIC0gRXZlbnQgY3JlYXRlZCBzdWNjZXNzZnVsbHlQQv+PNhoBFYEgEkQ2GgIVIhJENhoDSRUiEkQXQAAzgCNUaWNrZXQgcHJpY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gMEkVFlcGAkxQKExQsCNDgFRUaWNrZXQgcHVyY2hhc2VkIHN1Y2Nlc3NmdWxseS4gVHJhbnNmZXIgZnJvemVuIHRvIHByZXZlbnQgc2NhbHBpbmcgdW50aWwgZXZlbnQgZGF0ZS5C/5k2GgFJFSISRBc2GgJJFSISRBc2GgNJFSISRBdMIQQLTwJMCQ9BAEaANkZyZWV6ZSBjYW4gYmUgcmVsZWFzZWQgLSB0aWNrZXQgY2FuIG5vdyBiZSB0cmFuc2ZlcnJlZEkVFlcGAkxQKExQsCNDgCtUaWNrZXQgc3RpbGwgZnJvemVuLiBXaWxsIGJlIHJlbGVhc2VkIHNvb24uQv/CNhoBSRWBIBJENhoCSRUjEkQ2GgNJFSISRBdMJFNBAFOAQ0Nhbm5vdCB0cmFuc2ZlciAtIHRpY2tldCBpcyBmcm96ZW4uIFdhaXQgdW50aWwgZnJlZXplIHJlbGVhc2UgZGF0ZS5JFRZXBgJMUChMULAjQ0lBAF5JJQxAAFRJsbIISwGyByOyECSyAbOAQFRpY2tldCB0cmFuc2ZlcnJlZCBzdWNjZXNzZnVsbHkuIFRyYW5zZmVyIGZlZSBzZW50IHRvIG5ldyBvd25lci5C/5QlQv+pgC1UaWNrZXQgdHJhbnNmZXJyZWQgc3VjY2Vzc2Z1bGx5IHRvIG5ldyBvd25lci5C/142GgFJJFmBAghLARUSRFcCADYaAhUiEkQ2GgNJFSMSRCRTQQAxgAZGcm96ZW6AB0V2ZW50OiBLAlCACiwgU3RhdHVzOiBQTFBJFRZXBgJMUChMULAjQ4AIVW5mcm96ZW5C/8o2GgFJFSISRBeBkE4NQQA/gC9Sb3lhbHR5IGNhbm5vdCBleGNlZWQgMTAwJSAoMTAwMDAgYmFzaXMgcG9pbnRzKUkVFlcGAkxQKExQsCNDgBxSb3lhbHR5IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5Qv/RNhoBSRUiEkQXNhoCSRUiEkQXNhoDSRUiEkQXIQQLTwJMCQxBADWAJUNhbm5vdCByZWxlYXNlIGZyZWV6ZSB5ZXQgLSB0b28gZWFybHlJFRZXBgJMUChMULAjQ4AYRnJlZXplIG1hbnVhbGx5IHJlbGVhc2VkQv/VNhoBSRWBIBJENhoCSRUiEkQXNhoDSRUiEkQXSTYaBEkVIhJEF0lOAjYaBUkVIhJEF04CDkEAOoAqQ2Fubm90IHJlZnVuZCAtIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkSRUWVwYCTFAoTFCwI0NLA0AABClC/+lJIQQLSwNMCUsCDkEAL4AqQ2Fubm90IHJlZnVuZCAtIHJlZnVuZCBkZWFkbGluZSBoYXMgcGFzc2VkQv+sSwMlDEAAP0sDsbIISwSyByOyECSyAbOAKlJlZnVuZCBzZW50IHN1Y2Nlc3NmdWxseSB0byBidXllciBhZGRyZXNzLkL/ZiVC/782GgFJFYEgEkQ2GgJJFSISRBdJNhoDFSISRDYaBBUiEkRAAA8pSRUWVwYCTFAoTFCwI0NJJQxAAElJsbIISwGyByOyECSyAbOANUV2ZW50IGNhbmNlbGxhdGlvbiByZWZ1bmQgc2VudCBzdWNjZXNzZnVsbHkgdG8gYnV5ZXIuQv+jJUL/tA==","clear":"C4EBQw=="},"compilerInfo":{"compiler":"puya","compilerVersion":{"major":5,"minor":4,"patch":0}},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


/**
 * The argument types for the NftTicket contract
 */
export type NftTicketArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'create_ticket_event(string,uint64,uint64,uint64,uint64)string': {
      eventName: string
      eventDateTimestamp: bigint | number
      price: bigint | number
      releaseDays: bigint | number
      royalty: bigint | number
    }
    'purchase_ticket(address,uint64,uint64)string': {
      buyerAddress: string
      eventDate: bigint | number
      ticketPrice: bigint | number
    }
    'check_freeze_status(uint64,uint64,uint64)string': {
      eventDate: bigint | number
      releaseDays: bigint | number
      currentTime: bigint | number
    }
    'transfer_ticket(address,bool,uint64)string': {
      newOwnerAddress: string
      isFrozen: boolean
      transferFee: bigint | number
    }
    'get_ticket_info(string,uint64,bool)string': {
      eventName: string
      price: bigint | number
      isFrozen: boolean
    }
    'update_royalty(uint64)string': {
      newRoyalty: bigint | number
    }
    'emergency_freeze()string': Record<string, never>
    'release_freeze(uint64,uint64,uint64)string': {
      eventDate: bigint | number
      currentTime: bigint | number
      releaseDays: bigint | number
    }
    'refund_ticket(address,uint64,uint64,uint64,uint64)string': {
      buyerAddress: string
      refundAmount: bigint | number
      eventDate: bigint | number
      currentTime: bigint | number
      refundDeadlineDays: bigint | number
    }
    'cancel_event_refund(address,uint64,uint64,uint64)string': {
      buyerAddress: string
      refundAmount: bigint | number
      eventDate: bigint | number
      currentTime: bigint | number
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'create_ticket_event(string,uint64,uint64,uint64,uint64)string': [eventName: string, eventDateTimestamp: bigint | number, price: bigint | number, releaseDays: bigint | number, royalty: bigint | number]
    'purchase_ticket(address,uint64,uint64)string': [buyerAddress: string, eventDate: bigint | number, ticketPrice: bigint | number]
    'check_freeze_status(uint64,uint64,uint64)string': [eventDate: bigint | number, releaseDays: bigint | number, currentTime: bigint | number]
    'transfer_ticket(address,bool,uint64)string': [newOwnerAddress: string, isFrozen: boolean, transferFee: bigint | number]
    'get_ticket_info(string,uint64,bool)string': [eventName: string, price: bigint | number, isFrozen: boolean]
    'update_royalty(uint64)string': [newRoyalty: bigint | number]
    'emergency_freeze()string': []
    'release_freeze(uint64,uint64,uint64)string': [eventDate: bigint | number, currentTime: bigint | number, releaseDays: bigint | number]
    'refund_ticket(address,uint64,uint64,uint64,uint64)string': [buyerAddress: string, refundAmount: bigint | number, eventDate: bigint | number, currentTime: bigint | number, refundDeadlineDays: bigint | number]
    'cancel_event_refund(address,uint64,uint64,uint64)string': [buyerAddress: string, refundAmount: bigint | number, eventDate: bigint | number, currentTime: bigint | number]
  }
}

/**
 * The return type for each method
 */
export type NftTicketReturns = {
  'create_ticket_event(string,uint64,uint64,uint64,uint64)string': string
  'purchase_ticket(address,uint64,uint64)string': string
  'check_freeze_status(uint64,uint64,uint64)string': string
  'transfer_ticket(address,bool,uint64)string': string
  'get_ticket_info(string,uint64,bool)string': string
  'update_royalty(uint64)string': string
  'emergency_freeze()string': string
  'release_freeze(uint64,uint64,uint64)string': string
  'refund_ticket(address,uint64,uint64,uint64,uint64)string': string
  'cancel_event_refund(address,uint64,uint64,uint64)string': string
}

/**
 * Defines the types of available calls and state of the NftTicket smart contract.
 */
export type NftTicketTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'create_ticket_event(string,uint64,uint64,uint64,uint64)string' | 'create_ticket_event', {
      argsObj: NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']
      argsTuple: NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']
      returns: NftTicketReturns['create_ticket_event(string,uint64,uint64,uint64,uint64)string']
    }>
    & Record<'purchase_ticket(address,uint64,uint64)string' | 'purchase_ticket', {
      argsObj: NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string']
      argsTuple: NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']
      returns: NftTicketReturns['purchase_ticket(address,uint64,uint64)string']
    }>
    & Record<'check_freeze_status(uint64,uint64,uint64)string' | 'check_freeze_status', {
      argsObj: NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string']
      argsTuple: NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']
      returns: NftTicketReturns['check_freeze_status(uint64,uint64,uint64)string']
    }>
    & Record<'transfer_ticket(address,bool,uint64)string' | 'transfer_ticket', {
      argsObj: NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string']
      argsTuple: NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']
      returns: NftTicketReturns['transfer_ticket(address,bool,uint64)string']
    }>
    & Record<'get_ticket_info(string,uint64,bool)string' | 'get_ticket_info', {
      argsObj: NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string']
      argsTuple: NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']
      returns: NftTicketReturns['get_ticket_info(string,uint64,bool)string']
    }>
    & Record<'update_royalty(uint64)string' | 'update_royalty', {
      argsObj: NftTicketArgs['obj']['update_royalty(uint64)string']
      argsTuple: NftTicketArgs['tuple']['update_royalty(uint64)string']
      returns: NftTicketReturns['update_royalty(uint64)string']
    }>
    & Record<'emergency_freeze()string' | 'emergency_freeze', {
      argsObj: NftTicketArgs['obj']['emergency_freeze()string']
      argsTuple: NftTicketArgs['tuple']['emergency_freeze()string']
      returns: NftTicketReturns['emergency_freeze()string']
    }>
    & Record<'release_freeze(uint64,uint64,uint64)string' | 'release_freeze', {
      argsObj: NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string']
      argsTuple: NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']
      returns: NftTicketReturns['release_freeze(uint64,uint64,uint64)string']
    }>
    & Record<'refund_ticket(address,uint64,uint64,uint64,uint64)string' | 'refund_ticket', {
      argsObj: NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string']
      argsTuple: NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']
      returns: NftTicketReturns['refund_ticket(address,uint64,uint64,uint64,uint64)string']
    }>
    & Record<'cancel_event_refund(address,uint64,uint64,uint64)string' | 'cancel_event_refund', {
      argsObj: NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string']
      argsTuple: NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']
      returns: NftTicketReturns['cancel_event_refund(address,uint64,uint64,uint64)string']
    }>
}

/**
 * Defines the possible abi call signatures.
 */
export type NftTicketSignatures = keyof NftTicketTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type NftTicketNonVoidMethodSignatures = keyof NftTicketTypes['methods'] extends infer T ? T extends keyof NftTicketTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the NftTicket smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends NftTicketSignatures> = NftTicketTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the NftTicket smart contract to the method's return type
 */
export type MethodReturn<TSignature extends NftTicketSignatures> = NftTicketTypes['methods'][TSignature]['returns']


/**
 * Defines supported create method params for this smart contract
 */
export type NftTicketCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type NftTicketDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: NftTicketCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the NftTicket smart contract
 */
export abstract class NftTicketParamsFactory {
  /**
   * Constructs a no op call for the create_ticket_event(string,uint64,uint64,uint64,uint64)string ABI method
   *
   * Create a new NFT ticket event
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createTicketEvent(params: CallParams<NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'create_ticket_event(string,uint64,uint64,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventName, params.args.eventDateTimestamp, params.args.price, params.args.releaseDays, params.args.royalty],
    }
  }
  /**
   * Constructs a no op call for the purchase_ticket(address,uint64,uint64)string ABI method
   *
   * Purchase a ticket - accepts payment and confirms purchase
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static purchaseTicket(params: CallParams<NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string'] | NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'purchase_ticket(address,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.buyerAddress, params.args.eventDate, params.args.ticketPrice],
    }
  }
  /**
   * Constructs a no op call for the check_freeze_status(uint64,uint64,uint64)string ABI method
   *
   * Check if ticket should be frozen based on event date
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static checkFreezeStatus(params: CallParams<NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'check_freeze_status(uint64,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventDate, params.args.releaseDays, params.args.currentTime],
    }
  }
  /**
   * Constructs a no op call for the transfer_ticket(address,bool,uint64)string ABI method
   *
   * Transfer ticket to another address - can optionally send transfer fee
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static transferTicket(params: CallParams<NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string'] | NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'transfer_ticket(address,bool,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newOwnerAddress, params.args.isFrozen, params.args.transferFee],
    }
  }
  /**
   * Constructs a no op call for the get_ticket_info(string,uint64,bool)string ABI method
   *
   * Get ticket information
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getTicketInfo(params: CallParams<NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string'] | NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_ticket_info(string,uint64,bool)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventName, params.args.price, params.args.isFrozen],
    }
  }
  /**
   * Constructs a no op call for the update_royalty(uint64)string ABI method
   *
   * Update royalty rate
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateRoyalty(params: CallParams<NftTicketArgs['obj']['update_royalty(uint64)string'] | NftTicketArgs['tuple']['update_royalty(uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_royalty(uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newRoyalty],
    }
  }
  /**
   * Constructs a no op call for the emergency_freeze()string ABI method
   *
   * Emergency freeze - can freeze ticket anytime
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static emergencyFreeze(params: CallParams<NftTicketArgs['obj']['emergency_freeze()string'] | NftTicketArgs['tuple']['emergency_freeze()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'emergency_freeze()string' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the release_freeze(uint64,uint64,uint64)string ABI method
   *
   * Release freeze if current time is past freeze release date
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static releaseFreeze(params: CallParams<NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'release_freeze(uint64,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.eventDate, params.args.currentTime, params.args.releaseDays],
    }
  }
  /**
   * Constructs a no op call for the refund_ticket(address,uint64,uint64,uint64,uint64)string ABI method
   *
   * Refund ticket to buyer address - sends Algo back to buyer
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static refundTicket(params: CallParams<NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'refund_ticket(address,uint64,uint64,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.buyerAddress, params.args.refundAmount, params.args.eventDate, params.args.currentTime, params.args.refundDeadlineDays],
    }
  }
  /**
   * Constructs a no op call for the cancel_event_refund(address,uint64,uint64,uint64)string ABI method
   *
   * Emergency refund when event is cancelled - sends Algo back to buyer anytime
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancelEventRefund(params: CallParams<NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'cancel_event_refund(address,uint64,uint64,uint64)string' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.buyerAddress, params.args.refundAmount, params.args.eventDate, params.args.currentTime],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the NftTicket smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class NftTicketFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `NftTicketFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new NftTicketClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new NftTicketClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the NftTicket smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: NftTicketDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new NftTicketClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NftTicket smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NftTicket smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NftTicket smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new NftTicketClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the NftTicket smart contract
 */
export class NftTicketClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `NftTicketClient`
   *
   * @param appClient An `AppClient` instance which has been created with the NftTicket app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `NftTicketClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends NftTicketNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `NftTicketClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<NftTicketClient> {
    return new NftTicketClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `NftTicketClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<NftTicketClient> {
    return new NftTicketClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the NftTicket smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the NftTicket smart contract using the `create_ticket_event(string,uint64,uint64,uint64,uint64)string` ABI method.
     *
     * Create a new NFT ticket event
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createTicketEvent: (params: CallParams<NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.createTicketEvent(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `purchase_ticket(address,uint64,uint64)string` ABI method.
     *
     * Purchase a ticket - accepts payment and confirms purchase
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    purchaseTicket: (params: CallParams<NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string'] | NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.purchaseTicket(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `check_freeze_status(uint64,uint64,uint64)string` ABI method.
     *
     * Check if ticket should be frozen based on event date
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    checkFreezeStatus: (params: CallParams<NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.checkFreezeStatus(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `transfer_ticket(address,bool,uint64)string` ABI method.
     *
     * Transfer ticket to another address - can optionally send transfer fee
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    transferTicket: (params: CallParams<NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string'] | NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.transferTicket(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `get_ticket_info(string,uint64,bool)string` ABI method.
     *
     * Get ticket information
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getTicketInfo: (params: CallParams<NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string'] | NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.getTicketInfo(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `update_royalty(uint64)string` ABI method.
     *
     * Update royalty rate
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateRoyalty: (params: CallParams<NftTicketArgs['obj']['update_royalty(uint64)string'] | NftTicketArgs['tuple']['update_royalty(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.updateRoyalty(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `emergency_freeze()string` ABI method.
     *
     * Emergency freeze - can freeze ticket anytime
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    emergencyFreeze: (params: CallParams<NftTicketArgs['obj']['emergency_freeze()string'] | NftTicketArgs['tuple']['emergency_freeze()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(NftTicketParamsFactory.emergencyFreeze(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `release_freeze(uint64,uint64,uint64)string` ABI method.
     *
     * Release freeze if current time is past freeze release date
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    releaseFreeze: (params: CallParams<NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.releaseFreeze(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `refund_ticket(address,uint64,uint64,uint64,uint64)string` ABI method.
     *
     * Refund ticket to buyer address - sends Algo back to buyer
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    refundTicket: (params: CallParams<NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.refundTicket(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `cancel_event_refund(address,uint64,uint64,uint64)string` ABI method.
     *
     * Emergency refund when event is cancelled - sends Algo back to buyer anytime
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancelEventRefund: (params: CallParams<NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(NftTicketParamsFactory.cancelEventRefund(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the NftTicket smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the NftTicket smart contract using the `create_ticket_event(string,uint64,uint64,uint64,uint64)string` ABI method.
     *
     * Create a new NFT ticket event
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createTicketEvent: (params: CallParams<NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.createTicketEvent(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `purchase_ticket(address,uint64,uint64)string` ABI method.
     *
     * Purchase a ticket - accepts payment and confirms purchase
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    purchaseTicket: (params: CallParams<NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string'] | NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.purchaseTicket(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `check_freeze_status(uint64,uint64,uint64)string` ABI method.
     *
     * Check if ticket should be frozen based on event date
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    checkFreezeStatus: (params: CallParams<NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.checkFreezeStatus(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `transfer_ticket(address,bool,uint64)string` ABI method.
     *
     * Transfer ticket to another address - can optionally send transfer fee
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    transferTicket: (params: CallParams<NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string'] | NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.transferTicket(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `get_ticket_info(string,uint64,bool)string` ABI method.
     *
     * Get ticket information
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getTicketInfo: (params: CallParams<NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string'] | NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.getTicketInfo(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `update_royalty(uint64)string` ABI method.
     *
     * Update royalty rate
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateRoyalty: (params: CallParams<NftTicketArgs['obj']['update_royalty(uint64)string'] | NftTicketArgs['tuple']['update_royalty(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.updateRoyalty(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `emergency_freeze()string` ABI method.
     *
     * Emergency freeze - can freeze ticket anytime
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    emergencyFreeze: (params: CallParams<NftTicketArgs['obj']['emergency_freeze()string'] | NftTicketArgs['tuple']['emergency_freeze()string']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.emergencyFreeze(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `release_freeze(uint64,uint64,uint64)string` ABI method.
     *
     * Release freeze if current time is past freeze release date
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    releaseFreeze: (params: CallParams<NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.releaseFreeze(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `refund_ticket(address,uint64,uint64,uint64,uint64)string` ABI method.
     *
     * Refund ticket to buyer address - sends Algo back to buyer
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    refundTicket: (params: CallParams<NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.refundTicket(params))
    },

    /**
     * Makes a call to the NftTicket smart contract using the `cancel_event_refund(address,uint64,uint64,uint64)string` ABI method.
     *
     * Emergency refund when event is cancelled - sends Algo back to buyer anytime
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancelEventRefund: (params: CallParams<NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(NftTicketParamsFactory.cancelEventRefund(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the NftTicket smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the NftTicket smart contract using the `create_ticket_event(string,uint64,uint64,uint64,uint64)string` ABI method.
     *
     * Create a new NFT ticket event
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createTicketEvent: async (params: CallParams<NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.createTicketEvent(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['create_ticket_event(string,uint64,uint64,uint64,uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `purchase_ticket(address,uint64,uint64)string` ABI method.
     *
     * Purchase a ticket - accepts payment and confirms purchase
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    purchaseTicket: async (params: CallParams<NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string'] | NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.purchaseTicket(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['purchase_ticket(address,uint64,uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `check_freeze_status(uint64,uint64,uint64)string` ABI method.
     *
     * Check if ticket should be frozen based on event date
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    checkFreezeStatus: async (params: CallParams<NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.checkFreezeStatus(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['check_freeze_status(uint64,uint64,uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `transfer_ticket(address,bool,uint64)string` ABI method.
     *
     * Transfer ticket to another address - can optionally send transfer fee
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    transferTicket: async (params: CallParams<NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string'] | NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.transferTicket(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['transfer_ticket(address,bool,uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `get_ticket_info(string,uint64,bool)string` ABI method.
     *
     * Get ticket information
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getTicketInfo: async (params: CallParams<NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string'] | NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.getTicketInfo(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['get_ticket_info(string,uint64,bool)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `update_royalty(uint64)string` ABI method.
     *
     * Update royalty rate
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateRoyalty: async (params: CallParams<NftTicketArgs['obj']['update_royalty(uint64)string'] | NftTicketArgs['tuple']['update_royalty(uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.updateRoyalty(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['update_royalty(uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `emergency_freeze()string` ABI method.
     *
     * Emergency freeze - can freeze ticket anytime
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    emergencyFreeze: async (params: CallParams<NftTicketArgs['obj']['emergency_freeze()string'] | NftTicketArgs['tuple']['emergency_freeze()string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.emergencyFreeze(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['emergency_freeze()string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `release_freeze(uint64,uint64,uint64)string` ABI method.
     *
     * Release freeze if current time is past freeze release date
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    releaseFreeze: async (params: CallParams<NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.releaseFreeze(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['release_freeze(uint64,uint64,uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `refund_ticket(address,uint64,uint64,uint64,uint64)string` ABI method.
     *
     * Refund ticket to buyer address - sends Algo back to buyer
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    refundTicket: async (params: CallParams<NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.refundTicket(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['refund_ticket(address,uint64,uint64,uint64,uint64)string'])}
    },

    /**
     * Makes a call to the NftTicket smart contract using the `cancel_event_refund(address,uint64,uint64,uint64)string` ABI method.
     *
     * Emergency refund when event is cancelled - sends Algo back to buyer anytime
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancelEventRefund: async (params: CallParams<NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(NftTicketParamsFactory.cancelEventRefund(params))
      return {...result, return: result.return as unknown as (undefined | NftTicketReturns['cancel_event_refund(address,uint64,uint64,uint64)string'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new NftTicketClient(this.appClient.clone(params))
  }

  /**
   * Methods to access state for the current NftTicket app
   */
  state = {
  }

  public newGroup(): NftTicketComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a create_ticket_event(string,uint64,uint64,uint64,uint64)string method call against the NftTicket contract
       */
      createTicketEvent(params: CallParams<NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createTicketEvent(params)))
        resultMappers.push((v) => client.decodeReturnValue('create_ticket_event(string,uint64,uint64,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a purchase_ticket(address,uint64,uint64)string method call against the NftTicket contract
       */
      purchaseTicket(params: CallParams<NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string'] | NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.purchaseTicket(params)))
        resultMappers.push((v) => client.decodeReturnValue('purchase_ticket(address,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a check_freeze_status(uint64,uint64,uint64)string method call against the NftTicket contract
       */
      checkFreezeStatus(params: CallParams<NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.checkFreezeStatus(params)))
        resultMappers.push((v) => client.decodeReturnValue('check_freeze_status(uint64,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a transfer_ticket(address,bool,uint64)string method call against the NftTicket contract
       */
      transferTicket(params: CallParams<NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string'] | NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.transferTicket(params)))
        resultMappers.push((v) => client.decodeReturnValue('transfer_ticket(address,bool,uint64)string', v))
        return this
      },
      /**
       * Add a get_ticket_info(string,uint64,bool)string method call against the NftTicket contract
       */
      getTicketInfo(params: CallParams<NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string'] | NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getTicketInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_ticket_info(string,uint64,bool)string', v))
        return this
      },
      /**
       * Add a update_royalty(uint64)string method call against the NftTicket contract
       */
      updateRoyalty(params: CallParams<NftTicketArgs['obj']['update_royalty(uint64)string'] | NftTicketArgs['tuple']['update_royalty(uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateRoyalty(params)))
        resultMappers.push((v) => client.decodeReturnValue('update_royalty(uint64)string', v))
        return this
      },
      /**
       * Add a emergency_freeze()string method call against the NftTicket contract
       */
      emergencyFreeze(params: CallParams<NftTicketArgs['obj']['emergency_freeze()string'] | NftTicketArgs['tuple']['emergency_freeze()string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.emergencyFreeze(params)))
        resultMappers.push((v) => client.decodeReturnValue('emergency_freeze()string', v))
        return this
      },
      /**
       * Add a release_freeze(uint64,uint64,uint64)string method call against the NftTicket contract
       */
      releaseFreeze(params: CallParams<NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.releaseFreeze(params)))
        resultMappers.push((v) => client.decodeReturnValue('release_freeze(uint64,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a refund_ticket(address,uint64,uint64,uint64,uint64)string method call against the NftTicket contract
       */
      refundTicket(params: CallParams<NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.refundTicket(params)))
        resultMappers.push((v) => client.decodeReturnValue('refund_ticket(address,uint64,uint64,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a cancel_event_refund(address,uint64,uint64,uint64)string method call against the NftTicket contract
       */
      cancelEventRefund(params: CallParams<NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.cancelEventRefund(params)))
        resultMappers.push((v) => client.decodeReturnValue('cancel_event_refund(address,uint64,uint64,uint64)string', v))
        return this
      },
      /**
       * Add a clear state call to the NftTicket contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as NftTicketComposer
  }
}
export type NftTicketComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the create_ticket_event(string,uint64,uint64,uint64,uint64)string ABI method.
   *
   * Create a new NFT ticket event
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createTicketEvent(params?: CallParams<NftTicketArgs['obj']['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['create_ticket_event(string,uint64,uint64,uint64,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['create_ticket_event(string,uint64,uint64,uint64,uint64)string'] | undefined]>

  /**
   * Calls the purchase_ticket(address,uint64,uint64)string ABI method.
   *
   * Purchase a ticket - accepts payment and confirms purchase
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  purchaseTicket(params?: CallParams<NftTicketArgs['obj']['purchase_ticket(address,uint64,uint64)string'] | NftTicketArgs['tuple']['purchase_ticket(address,uint64,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['purchase_ticket(address,uint64,uint64)string'] | undefined]>

  /**
   * Calls the check_freeze_status(uint64,uint64,uint64)string ABI method.
   *
   * Check if ticket should be frozen based on event date
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  checkFreezeStatus(params?: CallParams<NftTicketArgs['obj']['check_freeze_status(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['check_freeze_status(uint64,uint64,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['check_freeze_status(uint64,uint64,uint64)string'] | undefined]>

  /**
   * Calls the transfer_ticket(address,bool,uint64)string ABI method.
   *
   * Transfer ticket to another address - can optionally send transfer fee
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  transferTicket(params?: CallParams<NftTicketArgs['obj']['transfer_ticket(address,bool,uint64)string'] | NftTicketArgs['tuple']['transfer_ticket(address,bool,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['transfer_ticket(address,bool,uint64)string'] | undefined]>

  /**
   * Calls the get_ticket_info(string,uint64,bool)string ABI method.
   *
   * Get ticket information
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getTicketInfo(params?: CallParams<NftTicketArgs['obj']['get_ticket_info(string,uint64,bool)string'] | NftTicketArgs['tuple']['get_ticket_info(string,uint64,bool)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['get_ticket_info(string,uint64,bool)string'] | undefined]>

  /**
   * Calls the update_royalty(uint64)string ABI method.
   *
   * Update royalty rate
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateRoyalty(params?: CallParams<NftTicketArgs['obj']['update_royalty(uint64)string'] | NftTicketArgs['tuple']['update_royalty(uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['update_royalty(uint64)string'] | undefined]>

  /**
   * Calls the emergency_freeze()string ABI method.
   *
   * Emergency freeze - can freeze ticket anytime
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  emergencyFreeze(params?: CallParams<NftTicketArgs['obj']['emergency_freeze()string'] | NftTicketArgs['tuple']['emergency_freeze()string']>): NftTicketComposer<[...TReturns, NftTicketReturns['emergency_freeze()string'] | undefined]>

  /**
   * Calls the release_freeze(uint64,uint64,uint64)string ABI method.
   *
   * Release freeze if current time is past freeze release date
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  releaseFreeze(params?: CallParams<NftTicketArgs['obj']['release_freeze(uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['release_freeze(uint64,uint64,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['release_freeze(uint64,uint64,uint64)string'] | undefined]>

  /**
   * Calls the refund_ticket(address,uint64,uint64,uint64,uint64)string ABI method.
   *
   * Refund ticket to buyer address - sends Algo back to buyer
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  refundTicket(params?: CallParams<NftTicketArgs['obj']['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['refund_ticket(address,uint64,uint64,uint64,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['refund_ticket(address,uint64,uint64,uint64,uint64)string'] | undefined]>

  /**
   * Calls the cancel_event_refund(address,uint64,uint64,uint64)string ABI method.
   *
   * Emergency refund when event is cancelled - sends Algo back to buyer anytime
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  cancelEventRefund(params?: CallParams<NftTicketArgs['obj']['cancel_event_refund(address,uint64,uint64,uint64)string'] | NftTicketArgs['tuple']['cancel_event_refund(address,uint64,uint64,uint64)string']>): NftTicketComposer<[...TReturns, NftTicketReturns['cancel_event_refund(address,uint64,uint64,uint64)string'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the NftTicket smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): NftTicketComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): NftTicketComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<NftTicketComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<NftTicketComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<NftTicketComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<NftTicketComposerResults<TReturns>>
}
export type NftTicketComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

